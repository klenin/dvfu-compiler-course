# Исторический обзор.

### Появление языков программирования.
Планкалкюль - первый ЯП высокого уровня. Создан Конрадом Цузе для его машин серии Z. Содержал множество прогрессивных идеи программирования, не получил широкой огласки и не был реализован, т.к. создавался в фашистской Германии в конце войны.

Устройство машинного кода для компьютеров архитектуры фон Неймана. Использование мнемоник для упрощения программирования, появление автокода (мнемокода), его применение в ассемблере (сборщике). 

Развитие идей абстрактного программирования, появление высокоуровневых языков. Разработка компании IBM (Бэкус) - язык FORTRAN (FORmulaTRANslator), одна из ключевых возможностей языка - запись арифметических выражений с использованием обозначений принятых в математике, в том числе индексация многомерных массивов начиная с меньшего разряда. Язык был сильно привязан к архитектуре целевой машины IBM 704, в частности имел ограничение на размер программы, а также не поддерживал операции '>', '<', т.к. клавиатура машина не имел данных символов. Ориентированность на перфокарты, строгая разметка программного кода.

Структурное программирование, рекурсивные функции в языке Algol 58/60. Язык создавался международным комитетом ученных, с участием Эдсгера Дейкстра, был направлен на академические цели. Джон Бэкус, создатель FORTRAN, также участвовавший в разработке Alogol'a создал метаязык описания ЯП - БНФ для работы над Algol'ом. 
Структур данных, и механизмы ввода-вывода в Cobol'е - языке, разработанном Грейс Хоппер для создания коммерческих приложений. 
Первый функциональный ЯП - LISP, первоначальное предназначение - работа со списковыми данными, получил широкое применение в области создания ИИ. 

Современное положение ЯП первого поколения: широкое распространение FORTRAN'а и Cobol'а привело к появлению большого количества кода на этих языках, которое до сих пор используется/требуют поддержки со стороны программистов. Algol завоевавший популярность только в европейской университетской среде, сегодня почти вышел из практического использования. Функциональные наследники LISP'а являются популярными ЯП и в наше время, низкая производительность интерпретаторов и неудобный скобочный синтаксис, долгое время сдерживал рост их популярности. Lisp оказывает сильное влияние на современное развитие языков, применяется при обучении программированию.

### Второе поколение.
В следующем поколении языка FORTRAN - FORTRAN II были учтены проблемы первого, в частности проблема с переносимостью кода, отчасти была разрешена при помощи введения механизма раздельной компиляции.

Язык PL1, еще одна разработка IBM, являлся попыткой объединить преимущества всех популярных языков того времени для создания универсального языка. Его реализация оказалась хорошим примером перегруженности языка, вследствие которой язык оказался сложным для изучения и использования. В этом языке также были впервые реализованы механизмы исключения, указатели и поддержка параллельного программирования.

После неудачного опыта с PL1 один из главных критериев разработке нового стандарта Algol'a - Algol 68 стала его ортогональность, одним из результатов которого стала введение типов, определяемых пользователем. Еще одним нововведением языка стали динамические массив, а также возможность использовать собственные наборы ключевых слов в т.ч. с использованием локальных кодировок. Провал языка во многом объясняется сложностью его описания, а также сложностью реализации компилятора для него.

BASIC (Beginers All-purpose Symbolic Instruction Code), был разработан для учебных целей, это во многом определило жесткие требования к простоте его изучения и использования, которую удалось достичь в отчасти ущерб производительности. Ключевым свойством языка стала его интерпретируемость, которая помимо простоты, также позволила сэкономить время необходимое для компиляции. Это свойство позволило использовать его для работы на терминалах и первых ПК.

### Третье поколение.
Pascal учебный ЯП, предок Algol'а 60. До сих пор является одним из наиболее популярных учебных языков. Современные диалекты активно используются и в промышленной разработке. Наряду с BASIC'ом является наглядным примером зависимости популярности языка от простоты его освоения.
C, язык разработанный Деннисом Ритчи для Bell Labaratories, изначально предназначался для системного программирования. Однако удачное сочетание минималистичности и достаточной выразительности, позволили создавать на нём высокопроизводительные программы в различных областях. Одной из ключевых особенностей языка стала слабая типизация и отсутствие проверки типов. Долгое время до появления ANSI C язык был не стандартизирован.

Modula, Modula-2, Oberon языки, созданные Виртом на базе Pascal'я. В этих языках Вирт попытался реализовать поддержку параллельности и модульности. В языке Oberon была добавлена поддержка, набирающего популярность ООП, а также автоматического управления памятью.

Prolog - логический ЯП. Планировался как замена императивным ЯП для компьютеров 5-го поколения. Ввиду неэффективности и сильного отличия от традиционных ЯП не приобрел популярность среди программистов. Сегодня используется в основном в учебных целях и при разработке в области ИИ и экспертных систем.

### Современные языки.
Кроме интерпретации и компиляции, многие современные языки также позволяют компиляцию в режиме JIT (just in time), при которой компиляция выполняется непосредственно в момент запуска кода. Основная цель использования JIT — достичь и превзойти производительность статической компиляции, сохраняя при этом преимущества динамический языков. 

Большинство современных компиляторов в результате трансляции создает объектные модули, которые помимо машинного кода модуля, также содержат таблицы символов, при помощи которых модули ищут необходимые для их работы имена. На следующем этапе подготовки программы linker, из объектных файлов создает исполняемые файлы или динамически подключаемые библиотеки. Запуск исполняемых файлов выполняет загрузчик, который подгружает необходимые динамически подключаемые библиотеки, выполняет загрузку программы и заменяет относительные адреса на абсолютные.

Многие языки программирования компилируется не в машинный код целевой платформы, а в байт-код виртуальной машины. Достоинством подобного способа выполнения программ является полная независимость байт-кода от операционной системы и оборудования, что позволяет выполнять приложения на любом устройстве, для которого существует соответствующая виртуальная машина. Другой важной особенностью данной технологии является гибкая система безопасности, в рамках которой исполнение программы полностью контролируется виртуальной машиной. Как всегда платой за эти преимущества является потеря производительности в сравнении с традиционной компиляцией.	Таким образом, в таких системах целевым языком для компилятора становиться байт-код ВМ, которая в свою очередь выполняет функции интерпретатора байт-кода. Использование различных техник JIT-компиляции позволяет сравниться им по скорости исполнения с компилируемыми языками.

Одним из способов написания первого компилятора нового языка или компилятора для новой платформы является bootstraping - раскручивание. Метод реализует компилятор поэтапно: на первом шаге создает ядро компилятора на языке ассемблера целевой платформы или ЯВУ, для которого уже был создан компилятор. Затем с его помощью создается аналогичный компилятор на реализованной части ЯП. Далее с помощью полученного компилятора, реализуются другие возможности языка, которые поэтапно добавляются к компилятору.  Кросс-компиляцией называется трансляция исходного кода в машинный код платформы, отличной от той, на которой происходит трансляция. Набор компиляторов GCC поддерживается на большинстве платформ, этого удалось достичь при помощи введения стандартизированного промежуточного представления кода в виде абстрактного дерева, по которому затем производиться генерации.

# Реализация компилятора.

### Общие вопросы и требования к разработке компилятора.
На самом верхнем уровне компилятор действует по схеме синтез-анализ, разбор программы на исходном языке, генерация кода целевого языка. В свою очередь разбор также принято делить на части. Лексический анализ - разделение входной программы на лексемы - минимальные цепочки символов имеющие отдельное значение. Синтаксический анализ - построение дерева разбора из распознанных токенов. Семантический анализ - проверка программы на семантическую корректность, построение таблицы символов. Процесс генерации делят на самому генерацию кода и улучшение полученного кода - оптимизацию.

Требования к функциональности программы:
+ front-end - подмножество ЯВУ (Си, Паскаль), включающее полный набор управляющих конструкций, сложные структуры данных, процедуры и функции, комментарии.
+ back-end - один из диалектов языка ассемблера.
+ Обработка ошибок при помощи механизма исключений, прекращение работы при первой обнаруженной ошибке.
+ Поддержка строк, операторов ввода, вывода.
+ Препроцессор - не требуется.
+ Оптимизация - опционально, в качестве доп. задания.
+ Интерпретация - опционально.

Требования к интерфейсу программы:
+ Работать как консольное приложение.
+ При запуске без аргументов выдавать краткую информацию об использовании, а также фамилию и номер группы автора.
+ Принимать в качестве аргумента в командной строке имя входного файла.
+ Принимать флаги с указанием необходимого этапа компиляции.	
+ Выдавать результаты на стандартный вывод (`stdout`).
+ В случае обнаружения ошибки выводить сообщение, включающее номер строки и номер символа, после прочтения которого была обнаружена ошибка.
+ Рекомендуется все сообщения выводить на правильном английском языке. В случае недостаточных знаний следует все сообщения выводить на транслите. Не допускается смешивать английский язык с транслитом.

Каждый этап компиляции должен быть выполнен в виде отдельного модуля/класса, кроме того для промежуточного представления компилируемой программы понадобятся стриктуры данных, реализация которых также должна быть вынесена в отдельные модули/классы.
Все этапы должны быть покрыты тестами. Большинство тестов следует делать атомарными, т.е. один тест должен покрывать 1-2 ветки исполнения, однако следует добавить и несколько комплексных тестов проверяющие систему в целом, по методу "черного ящика". Тестирование должно проводиться при помощи автоматического тестера, который запускает компилятор на тестах, сравнивает результаты с эталонными и формирует отчет. Если тесты содержаться в отдельных файлах их название следует начинать номером с дополняющими нулями, т.е. вместо `1.in` использовать `01.in` (если общее количество тестов < 100) или `001.in` (если < 1000). Результатами этапов разбора являются промежуточные представления исходного кода, поэтому следует обеспечить компилятор функциями вывода на консоль элементов этих представлений в удобной для проверки форме (использовать табуляцию и короткие обозначения < 8 символов).

### Лексический анализ.
Идея регулярных выражений. Базовый набор операторов РВ их приоритет:
+ \ - экранирование
+ () - скобки приоритета
+ \* - замыкание Клини (ноль или больше)
+ конкатенация
+ | - дизъюнкция (или)

Примеры РВ. Расширенные РВ, обратные ссылки.
Конечные автоматы, формальное определение, эквивалентность РВ и конечных автоматов. Детерминированные и недерминированные конечные автоматы, алгоритм приведения НКА к ДКА. Разбор ДКА на примере вещественных чисел.
Понятия лексем и токенов, представление лексики языка с помощью РВ, реализация анализатора ДКА.

Требования к лексике языка:
+ многострочные и однострочные комментарии
+ свободный синтаксис - пробельные символы только для разделение лексем
+ вещественные числа в экспоненциальной форме и форме с точкой
+ разделение идентификаторов и ключевых слов
+ жадный алгоритм многосимвольных лексем

Интерфейс класс `Lexer`: конструктор, метод `Token get_token()`, структура класса `Token`, метод `print()`.
Автоматические лексические анализаторы - LEX, FLEX.

Стратегии восстановления после ошибок:
+ "режим паники"
+ эвристические методы
+ минимальное количество преобразований

### Синтаксический анализ.
Формальные грамматики основные определения, иерархия Хомского. Примеры регулярной и контекстно-свободной грамматики. Запись грамматики в форме Бэкуса-Ноера, в виде синтаксических диаграмм. 
Алгоритмы синтаксического разбора: Кока-Янгера-Касами, восходящего и нисходящего спуска. 
Понятие синтаксического дерева разбора, его построение на примере простых арифметических выражений методом рекурсивного спуска. Проблема леворекурсивных грамматик. 
Рассмотрение методов класса `Parser` для построения соответствующих узлов, взаимодействие с `Lexer`'ом, класс `SynNode` - узел синтаксического дерева
. Форматы вывода деревьев:
+ Скобочный формат - узел дерева представляется либо атомом (константы и идентификаторы), либо списком элементов, разделённых пробелами и заключённым в круглые скобки.
+ Древовидный формат - узел дерева отдельной строкой с отступом, равным глубине вложенности данного узла. Вложенные элементы выводятся после корневого с увеличенным уровнем вложенности.

Разбор операторов, функций и описаний переменных.
Автоматические синтаксические анализаторы - YACC, Bison. 

### Семантический анализ.
Области видимости переменных: локальные и глобальные переменные, переменные вложенных блоков. 
Типизация: сильная и слабая, явная и неявная, динамическая и статическая. Преобразование типов, правила неявного преобразования, операторы статического и динамического приведения типов на примере языка Си++.
Объявление функции и структур данных: прототипы, проверка корректности вызова функций и обращение к полям структур.
Реализация семантического анализа в методах `Parser`'а и `SynNode`'а, реализация классов `SymType` и `SymTable` - типов данных и таблиц символов.

### Генерация кода.
Современные ассемблеры: FASM, MASM, TASM, NASM, gas. Особенности синтаксиса: Intel и AT&T нотация, макросы. Ассемблеры не Intel архитектур. Дизассемблеры и отладчики, крякинг: OllyDbg, WinDbg, gdb.
Генерация кода арифметических выражений с использованием стека. Алгоритм сортировочной станции. Работа с вещественными числами.
Генерация кода для структур данных, организация работы со строками, операторы ввода, вывода.
Генерация управляющих операторов.
Генерация кода функций, и их вызова. Стековый фрейм, передача аргументов с использованием стека, адрес возврата, локальные переменные.

### Оптимизация.
Критерии оптимизации: объем кода, объем занимаемой оперативной памяти, время работы.
Типы оптимизации:
+ peephole-оптимизация
+ локальная оптимизация
+ оптимизация циклов
+ глобальная оптимизация
